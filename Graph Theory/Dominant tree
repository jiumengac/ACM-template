//#pragma GCC optimize(2)
//#pragma GCC optimize(3)
//#pragma GCC optimize(4)
//#pragma GCC optimize("unroll-loops")
//#pragma comment(linker, "/stack:200000000")
//#pragma GCC optimize("Ofast,no-stack-protector")
//#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#include<bits/stdc++.h>
#define fi first
#define se second
#define db double
#define mp make_pair
#define pb push_back
#define pi acos(-1.0)
#define ll long long
#define vi vector<int>
#define mod 1000000007
#define ld long double
//#define C 0.5772156649
#define ls l,m,rt<<1
#define rs m+1,r,rt<<1|1
#define pll pair<ll,ll>
#define pil pair<int,ll>
#define pli pair<ll,int>
#define pii pair<int,int>
//#define cd complex<double>
#define ull unsigned long long
//#define base 1000000000000000000
#define fin freopen("a.txt","r",stdin)
#define fout freopen("a.txt","w",stdout)
#define fio ios::sync_with_stdio(false);cin.tie(0)
inline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
inline void sub(ll &a,ll b){a-=b;if(a<0)a+=mod;}
inline void add(ll &a,ll b){a+=b;if(a>=mod)a-=mod;}
template<typename T>inline T const& MAX(T const &a,T const &b){return a>b?a:b;}
template<typename T>inline T const& MIN(T const &a,T const &b){return a<b?a:b;}
inline ll qp(ll a,ll b){ll ans=1;while(b){if(b&1)ans=ans*a%mod;a=a*a%mod,b>>=1;}return ans;}
inline ll qp(ll a,ll b,ll c){ll ans=1;while(b){if(b&1)ans=ans*a%c;a=a*a%c,b>>=1;}return ans;}

using namespace std;

const double eps=1e-8;
const ll INF=0x3f3f3f3f3f3f3f3f;
const int N=200000+10,maxn=200000+10,inf=0x3f3f3f3f;

struct edge{int to,Next,id;}e[maxn];
int cnt,head[N];
vi v[N],pre[N];
int deep[N],father[20][N];
int idom[N],sdom[N],id[N],dfn[N],fa[N],fas[N],res,par[N],n,m;
void init(){cnt=res=0;memset(head,-1,sizeof head);}
void add(int u,int v,int id){e[cnt].to=v;e[cnt].id=id;e[cnt].Next=head[u];head[u]=cnt++;}
void dfs(int u)
{
    id[dfn[u]=++res]=u;
    for(int i=head[u];~i;i=e[i].Next)
    {
        int x=e[i].to;
        if(!dfn[x])par[x]=u,dfs(x);
    }
}
void Find(int x)
{
    if(fa[x]==x)return ;
    Find(fa[x]);
    if(dfn[sdom[fas[fa[x]]]]<dfn[sdom[fas[x]]])fas[x]=fas[fa[x]];
    fa[x]=fa[fa[x]];
}
void build()
{
    dfs(1);
    for(int i=1;i<=n;i++)fa[i]=fas[i]=idom[i]=sdom[i]=i;
    for(int i=res;i>=1;i--)
    {
        int x=id[i];
        for(int j=0;j<pre[x].size();j++)
        {
            int y=pre[x][j];if(!dfn[y])continue;
            Find(y);
            if(dfn[sdom[fas[y]]]<dfn[sdom[x]])sdom[x]=sdom[fas[y]];
        }
        for(int j=0;j<v[x].size();j++)
        {
            int y=v[x][j];Find(y);
            if(dfn[sdom[fas[y]]]<i)idom[y]=fas[y];
            else idom[y]=x;
        }
        for(int j=head[x];~j;j=e[j].Next)if(par[e[j].to]==x)fa[e[j].to]=x;
        v[sdom[x]].pb(x);
    }
    for(int i=1;i<=n;i++)v[i].clear();
    for(int i=1;i<=res;i++)
    {
        int x=id[i];
        if(idom[x]!=sdom[x])idom[x]=idom[idom[x]];
        v[idom[x]].pb(x);
        printf("%d %d\n",x,idom[x]);
    }
}
int main()
{
    while(~scanf("%d%d",&n,&m))
    {
        init();
        memset(dfn,0,sizeof dfn);
        for(int i=1;i<=n;i++)pre[i].clear(),v[i].clear();
        for(int i=1;i<=m;i++)
        {
            int a,b;scanf("%d%d",&a,&b);
            add(a,b,i);pre[b].pb(a);
        }
        build();
    }
    return 0;
}
/********************
5 7
1 2
5 2
2 3
3 4
4 5
2 4
4 2
********************/
