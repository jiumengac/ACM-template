必胜点和必败点：
P点：必败点，换而言之，就是谁处于此位置，则在双方操作正确的情况下必败。
N点：必胜点，处于此情况下，双方操作均正确的情况下必胜。
必胜点和必败点的性质：
1、所有终结点是必败点P.
2、从任何必胜点N操作，至少有一种方式可以进入必败点P.
3、无论如何操作，必败点P都只能进入必胜点 N.
巴什博弈:只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜,n%(m+1)==0后手胜
威佐夫博弈:有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。
满足ak=k∗(1+sqrt(5))/2，bk=ak+k ，后手必胜，否则先手必胜。
斐波那契博弈：
有一堆个数为 n 的石子，游戏双方轮流取石子，满足：
1. 先手不能在第一次把所有的石子取完；
2. 之后每次可以取的石子数介于1到对手刚取的石子数的2倍之间（包含1和对手刚取的石子数的2倍）。
约定取走最后一个石子的人为赢家，求必败态。  
先手胜当且仅当n不是Fibonacci数
阶梯博弈:一堆石子,只能把后面的放到前面,最后没有点可以移动的人输,奇数堆做nim博弈
sg函数
1.可选步数为1-m的连续整数，直接取模即可，SG(x)=x%(m+1);
2.可选步数为任意步，SG(x) = x;
3.可选步数为一系列不连续的数，用GetSG(计算)
//线性求sg函数
int f[N],sg[N],Hash[N];
void getsg(int n)
{
    memset(sg,0,sizeof sg);
    for(int i=1;i<=n;i++)
    {
        memset(Hash,0,sizeof Hash);
        for(int j=0;f[j]<=i;j++)
            Hash[sg[i-f[j]]]=1;
        for(int j=0;j<=n;j++)
            if(Hash[j]==0)
            {
                sg[i]=j;
                break;
            }
    }
}

//单点sg函数
int s[101],sg[10001],k; //k为可走步数，s数组存储可走步数（0~k-1）
int getsg(int m)
{
    int hash[101]={0};
    int i;
    for(i=0; i<k; i++)
    {
        if(m-s[i]<0)
            break;
        if(sg[m-s[i]]==-1)
            sg[m-s[i]]=getsg(m-s[i]);
        hash[sg[m-s[i]]]=1;
    }
    for(i=0;; i++)
        if(hash[i]==0)
            return i;
}
