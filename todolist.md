C++
拷贝构造函数：
1.浅拷贝：默认拷贝构造函数是浅拷贝（不能用于动态分配）
class A{
private:
    int *p;
public:
    A(){p=new int();}
    ~A(){delete p;}
};
int main()
{
    A a;
    A b(a);
    return 0;
}
A a执行时p指向堆，执行浅拷贝时，只对成员赋值b.p=a.p,执行析构函数时会删除同一个堆空间，就会出错（即b.p指针悬挂）
2.深拷贝
class A{
private:
    int *p;
public:
    A(){p=new int();}
    A(const A&x){p=new int();*p=*x.p;}
    ~A(){delete p;}
};
int main()
{
    A a;
    A b(a);
    return 0;
}
完成拷贝后，a.p和b.p各指向一段内存空间，但是指向的空间内容相同！

对于一个类X, 如果一个构造函数的第一个参数是下列之一:
   a) X&
   b) const X&
   c) volatile X&
   d) const volatile X&
且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.
移动构造函数：
class A{
private:
    int *p;
public:
    A(){p=new int();}
    A(A &&rhs)
    {
        p=rhs.p;
        rhs.p=NULL;
        puts("!!!");
    }
    ~A()
    {
        if(p!=NULL)delete p;
        else puts("&&&");
    }
};
int main()
{
    A a;
    A b=move(a);
    return 0;
}
右值引用，避免a的拷贝，直接将a给b，同时删除a
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
常量函数
注意非成员函数不能有CV[const, volatile]限定，常量成员函数不能调用
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
值传递，引用传递，指针传递
值传递：实参的拷贝，不改变实参的值
引用传递：实参的地址，改变实参的值
指针传递：指针指向实参的地址，改变实参的值
引用和指针传递的区别：
1.引用不能改变引用地址，只是别名不是实体，而指针是实体
2.sizeof计算变量大小时，得到引用变量大小，指针大小4
3.可以const指针，没有const引用
4.引用传递不能为空。
5.可以多级指针
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
虚函数：子类函数覆盖基类函数
当基类指针指向基类对象时，调用的是基类的函数。
当基类指针指向子类对象时，调用的是子类的函数。
（即多态）
纯虚函数virtual void f()=0
基类中没有定义，但是任何派生类中都要实现该方法
目的：使派生类只是继承函数的接口
带有纯虚函数的类称为抽象类
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
public: 能被类成员函数、子类函数、友元访问，也能被类的对象访问。 
private: 只能被类成员函数及友元访问，不能被其他任何访问，本身的类对象也不行。 
protected: 只能被类成员函数、子类函数及友元访问，不能被其他任何访问，本身的类对象也不行
使用private继承，父类的protected和public属性在子类中变为private 
使用protected继承，父类的protected和public属性在子类中变为protected 
使用public继承，父类中的protected和public属性不发生改变



计网：
rtt：报文往返时间

tcp保证可靠性
1.序列号，确认应答，超时重传
2.窗口控制与高速重发控制、快速重传
（窗口大小：无需确认即可继续发送数据的最大值）
快速重传：发送端收到三次相同确认应答，会立即重发
3.拥塞控制
慢启动：开始窗口为1，每次收到确认应答（一个rtt），窗口×2
拥塞避免：设置慢启动阀值（65536）窗口达到阀值，不再指数增加，而是每次+1

ACK：确认比特，ACK=1，即确认号字段有效
SYN：同步比特，SYN=1，即连接请求
FIN：终止比特，FIN=1，即数据发送完毕请求释放连接

序列号seq
三次握手：
1.客户端：发送SYN连接报文,seq=x
2.服务器：发送SYN确认连接报文,seq=y，ACK=1
3.客户端：发送ACK确认报文,ACK=y+1

四次挥手：
客户端：发送FIN终止请求，seq=x+2，ACK=y+1
服务器：发送ACK=X+3确认
客户端收到ACK后会关闭从客户端到服务器的连接，服务器会继续发送没发完的数据
服务器：发送FIN，seq=y+1，表示没有数据了
客户端：发送ACK=y+2，关闭从服务器到客户端的连接

为什么TCP建立连接需要三次，而释放连接需要四次？
TCP释放连接时服务器的ACK和FIN是分开发送的（中间隔着数据传输），
而TCP建立连接时服务器的ACK和SYN是一起发送的（第二次握手），
所以 TCP 建立连接需要三次，而释放连接则需要四次。

TCP为什么要四次挥手？
因为TCP是全双工模式

TCP和UPD区别：
1.TCP面向连接，UDP无连接
2.TCP可靠，UDP尽力交付，不可靠
3.TCP点到点，UDP可多对多
4.UDP没有拥塞控制
5.TCP面向字节流，UDP面向保温
6.TCP收不开销20字节，UDP8字节

OSI七层模型
物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

TCP/IP 四层模型
网络接口层，网络层，传输层，应用层

区别TCP/UDP报文
看ip头中的协议标识字段，17是UDP，6是TCP

http/https区别
1.https明文，https有TLS加密
2.http协议端口80，https443
3.https协议需要服务端申请证书，浏览器安装对应的根证书

http返回码：
1xx:指示信息，表示请求已接受，继续处理
2xx：成功，请求已成功接受，理解，接受
3xx：重定向，请求必须进一步操作
4xx：客户端错误，请求有语法错误或请求无法实现
5xx：服务端错误，服务器不能实现合法请求

在浏览器输入url，按回车
1.浏览器在DNS服务器请求解析URL中域名对应IP地址
2.解析出IP后，根据IP地址和默认端口80，和服务器建立TCP链接
3.浏览器发出读取文件的http请求，该请求报文作为TCP三次握手的的第三个数据发送给服务器
4.服务器对浏览器请求做出相应，并把html文本发送给浏览器
5.释放tcp链接
6.浏览器将该html显示内容
